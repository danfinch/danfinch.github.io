<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Pre-modern Hyperscript - Dan Finch</title><meta name="description" content="I was working at Promitheia during the first days of “Web 2.0”."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://danfinch.github.io/pre-modern-hyperscript/"><link rel="alternate" type="application/atom+xml" href="https://danfinch.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://danfinch.github.io/feed.json"><meta property="og:title" content="Pre-modern Hyperscript"><meta property="og:site_name" content="Dan Finch"><meta property="og:description" content="I was working at Promitheia during the first days of “Web 2.0”."><meta property="og:url" content="https://danfinch.github.io/pre-modern-hyperscript/"><meta property="og:type" content="article"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:var(--body-font);--post-entry-font:var(--body-font);--logo-font:var(--body-font);--menu-font:var(--body-font)}</style><link rel="stylesheet" href="https://danfinch.github.io/assets/css/style.css?v=b72d6812efdcc84dc33e030b1151d45d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://danfinch.github.io/pre-modern-hyperscript/"},"headline":"Pre-modern Hyperscript","datePublished":"2021-09-14T19:54","dateModified":"2021-09-14T19:56","description":"I was working at Promitheia during the first days of “Web 2.0”.","author":{"@type":"Person","name":"Dan"},"publisher":{"@type":"Organization","name":"Dan"}}</script></head><body><div class="container"><header class="top" id="js-top"><div><a class="logo" href="https://danfinch.github.io/">Dan Finch</a><nav class="navbar"><button class="navbar__toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://danfinch.github.io/" title="About Me" target="_self">About</a></li><li><a href="https://danfinch.github.io/experience/" target="_self">Experience</a></li><li class="active-parent has-submenu"><a href="https://danfinch.github.io/tags/story/" target="_self" aria-haspopup="true">Stories</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://danfinch.github.io/coldwater-creek-product-catalog/" target="_self">Product Catalog</a></li><li><a href="https://danfinch.github.io/a-standing-ovation/" target="_self">Standing Ovation</a></li><li class="active"><a href="https://danfinch.github.io/pre-modern-hyperscript/" target="_self">Hyperscript</a></li></ul></li></ul></nav></div></header><main><article class="post wrapper"><div class="hero hero--full"><header><h1>Pre-modern Hyperscript</h1></header></div><div class="post__entry"><p>I was working at Promitheia during the first days of “Web 2.0”. AJAX was very popular but the tools to fill the gap between dynamic and static sites were not yet around. Server side rendering was necessary, but I still wanted to provide very interactive pages without adding a completely different client-side framework for rendering markup.</p><p>I settled on what some called AHAH - Asynchronous HTML And HTTP - where the server rendered partial views via XMLHttpRequests which were inserted into the DOM. I made use of a number of non-standard HTML attributes to declaratively wire up these insertions. As a result very few widgets needed custom code. jQuery was patched at startup to rebind events when content was inserted. I was able to achieve performant and flashy interactions with careful use of jQuery (it is possible!) long before they became commonplace.</p><p>Working with views in ASP.NET prior to the release of Razor was painful: unmaintainable soup markup was everywhere. As a result, many people were creating their own view engines. I did not have the bandwidth to create and maintain a custom view engine, let alone make it work with the IDE.</p><p>I decided to create a C#-based fluent DSL and write the views directly in the host language itself. People now call this hyperscript, and it is fairly common, but at the time (2008-ish), other programmers thought I was insane! This had many benefits - I did not have two syntaxes mixed up in the same file, I had all the support of my IDE (autocomplete, type checking), and I could package components as DLL files. Layout views could simply be written as methods with parameters for the “holes”.</p><p>In debug mode my view engine would set up a file watcher and auto-reload views as I worked on them; another perk which was scoffed at then but is now looked at as a standard feature of a web stack.</p></div><aside><p class="post__last-updated">This article was updated on September 14, 2021</p></aside></article></main></div><footer class="footer"><div class="footer__copyright"><p>Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://danfinch.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://danfinch.github.io/assets/js/scripts.min.js?v=18410cbe84c2356f2fa9c4bf730b3bca"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>