<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Coldwater Creek Product Catalog - Dan Finch</title><meta name="description" content="The Problem The project was explained to me as adding infinite scrolling&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://danfinch.github.io/coldwater-creek-product-catalog/"><link rel="alternate" type="application/atom+xml" href="https://danfinch.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://danfinch.github.io/feed.json"><meta property="og:title" content="Coldwater Creek Product Catalog"><meta property="og:site_name" content="Dan Finch"><meta property="og:description" content="The Problem The project was explained to me as adding infinite scrolling&hellip;"><meta property="og:url" content="https://danfinch.github.io/coldwater-creek-product-catalog/"><meta property="og:type" content="article"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:var(--body-font);--post-entry-font:var(--body-font);--logo-font:var(--body-font);--menu-font:var(--body-font)}</style><link rel="stylesheet" href="https://danfinch.github.io/assets/css/style.css?v=b72d6812efdcc84dc33e030b1151d45d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://danfinch.github.io/coldwater-creek-product-catalog/"},"headline":"Coldwater Creek Product Catalog","datePublished":"2021-09-14T19:46","dateModified":"2021-09-14T19:56","description":"The Problem The project was explained to me as adding infinite scrolling&hellip;","author":{"@type":"Person","name":"Dan"},"publisher":{"@type":"Organization","name":"Dan"}}</script></head><body><div class="container"><header class="top" id="js-top"><div><a class="logo" href="https://danfinch.github.io/">Dan Finch</a><nav class="navbar"><button class="navbar__toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://danfinch.github.io/" title="About Me" target="_self">About</a></li><li><a href="https://danfinch.github.io/experience/" target="_self">Experience</a></li><li class="active-parent has-submenu"><a href="https://danfinch.github.io/tags/story/" target="_self" aria-haspopup="true">Stories</a><ul class="navbar__submenu level-2" aria-hidden="true"><li class="active"><a href="https://danfinch.github.io/coldwater-creek-product-catalog/" target="_self">Product Catalog</a></li><li><a href="https://danfinch.github.io/a-standing-ovation/" target="_self">Standing Ovation</a></li><li><a href="https://danfinch.github.io/pre-modern-hyperscript/" target="_self">Hyperscript</a></li></ul></li></ul></nav></div></header><main><article class="post wrapper"><div class="hero hero--full"><header><h1>Coldwater Creek Product Catalog</h1></header></div><div class="post__entry"><h2 id="the-problem">The Problem</h2><p>The project was explained to me as adding infinite scrolling and some faceted search features to our product catalog. While researching and planning I soon realized these requirements meant a complete rewrite of the product catalog. The shape of our data in SQL Server was not at all amenable to faceted search. Another difficulty was that my manager was exiting and there seemed to be no single person in charge of the project, leaving me to fill in a lot of blanks.</p><p>Our existing catalog used a categorization system which required the content team to compose filters in a strange DSL:</p><pre><code>  Attribute&lt;Type&gt;(&#39;Pants&#39;)
  =&gt;Attribute&lt;Color&gt;(&#39;Blue&#39;)
</code></pre><p>The syntax of this language seemed arbitrarily complex and the parser was very touchy. Several hundred of these filters were translated dynamically at run-time (and quite slowly) to LINQ-to-SQL expression trees and then run against SQL Server to collect products matching the criteria. Often, heavy traffic would cause this to take down our servers - the SQL queries generated were sometimes many thousands of characters long.</p><p>My testing demonstrated that even if this query performance problem was solved, response times from DB to app servers would still be a major bottleneck. I was part of a conservative Microsoft stack team and putting caching layers like Redis and memcached between DB and app was a very hard sell.</p><h2 id="server-side">Server Side</h2><p>To implement a caching layer without raising any eyebrows, I simply pulled the entire product catalog into memory and put it behind an ASP.NET web service, using standard .NET collections to index it. A single, small VM in each datacenter would suffice as our cache, and our team would be capable of maintaining it without learning any scary open source tech!</p><p>To make life better for the content team I both rewrote the old expression tree parser to be less brittle and added a new DSL so new filters were legible to the non-technical users:</p><pre><code>  Type = Pants
  and Color = Blue
</code></pre><p>Compiling these to LINQ-to-SQL still performed poorly, and the code was difficult to maintain. Instead, I generated raw T-SQL using Common Table Expressions. All filters were parsed and run at cache startup, taking about 15 seconds to run the hundreds of queries and index the entire catalog. Faceted search was then done with the in-memory collections rather than the relational tables, giving instant results. We would have been able to spin down about 80% of our web servers had this gone into production. Unfortunately, the company announced it was liquidating shortly before launch.</p><h2 id="client-side">Client Side</h2><p>I had never actually used an infinite scroll feature which met my usability standards. Most of our direct competitors had implemented this, and all were slow or buggy. All the existing techniques I looked into had big flaws. We had the specific requirement: “if the user clicks the back button, she should wind up back at the same part of the infinite scroll she left”. The few existing implementations which met this requirement were essentially hacks, and did not work reliably.</p><p>Realizing that all browsers have this “where I left off” feature built-in for static pages, my solution was to pre-calculate and insert the CSS height of the entire results element at the server, where we knew 1) the fixed height of each result, and 2) how many results were on the page. Results were still fetched dynamically, but the user would <em>instantly</em> be where she left off when returning to the results. And no awkwardly shrinking/jumping scrollbar! I have yet to find this technique used anywhere else.</p><p>When complete, I could go to our “All Products” listing, hold down the Page Down button, and see the entire product catalog fly past in a matter of seconds.</p></div><aside><p class="post__last-updated">This article was updated on September 14, 2021</p></aside></article></main></div><footer class="footer"><div class="footer__copyright"><p>Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://danfinch.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://danfinch.github.io/assets/js/scripts.min.js?v=18410cbe84c2356f2fa9c4bf730b3bca"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>